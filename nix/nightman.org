* The Nightman

The Nightman Cometh
   for secrets that shouldn't be out after dark.

Check out secrets from the Nightman. Don't keep them longer than you
need them or he will take his secrets back forcibly.

Here is how the Nightman keeps track of his records.

In the beginning, the Nightman has all secrets under control.
- To decrypt a secret, 'checkout' a file. If necessary, be ready with
     authentication.
- When you are done with your secret, appease the Nightman with 'return'
- To clear bad locks, use 'flush'

#+NAME: include
#+BEGIN_SRC sh :tangle nightman
  source $HOME/Dropbox/config/bash/bash.io.sh
#+END_SRC

#+NAME: variables
#+BEGIN_SRC sh :tangle nightman
  nightman_suffix="nightman.lock"
#+END_SRC

#+NAME: commands
#+BEGIN_SRC sh :tangle nightman
  function lock() {
      touch `ls *${1##*/}.${nightman_suffix} 2>/dev/null | wc -l`.${1##*/}.${nightman_suffix}
  }

  function unlock() {
      file=${1%.gpg}
      rm `ls *${file##*/}.${nightman_suffix} 2>/dev/null | tail -n1` 2>/dev/null
      [[ -z `ls *${file##*/}.${nightman_suffix} 2>/dev/null` ]] && ${destroy} ${file} 2>/dev/null
  }

  destroy="shred -fuz"
  decrypt="gpg --batch -q"
#+END_SRC

Now to handle requests by action

#+BEGIN_SRC sh :tangle nightman
  function crypt() {
      unset encrypt query;
      case $1 in
          e|en|encrypt) encrypt=1 ;;
      esac; shift

      if [[ $encrypt ]]; then
          for arg; do         # Determine if authentication is necessary
              [[ -z $query && $1 && -e ${1%.gpg} ]] || query=1 # Does each file exist?
          done
          [[ $query ]] && query_password # Prompt user if necessary
      fi

      while [[ $1 ]]; do
          # If the secret is not out of the bottle, let it out
          [[ $encrypt && $query && ! -e ${1%.gpg} ]] && \
              gpg --batch -q --passphrase=${secret_passwd} -o ${1%.gpg} --decrypt ${1} \
              && chmod 600 ${1%.gpg} 2>/dev/null

          pushd `dirname $0` &>/dev/null # Add the lock in the dir containing this script
          {                              # Inside this block, lock or unlock the file
              if [[ $encrypt ]]; then lock ${1%.gpg}
              else                     unlock $1; fi
          }
          popd &>/dev/null
          shift
      done
  }

  case $1 in

      c|checkout) shift
          crypt encrypt $@ ;;

      r|return) shift
          crypt decrypt $@ ;;

      f|flush) shift
          pushd `dirname $0` &>/dev/null
          rm *${nightman_suffix} 2>/dev/null
          popd &>/dev/null
          ;;

      ""|h|help)
          cat <<EOF

  This is a literate program. See the documentation for details.

  EOF
          exit 1 ;;

      ,*) section "Unrecognized directive: $1"
          echo "Aborting" && exit 1 ;;
  esac
#+END_SRC
